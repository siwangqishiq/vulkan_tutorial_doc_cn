# 呈现

## 窗口表面

由于Vulkan 是一个平台无关的API，它本身并没有提供与窗口直接交互的接口，为了建立窗口与Vulkan的连接以将最终的渲染结果呈现到屏幕上,我们需要使用WSI扩展(窗口集成系统),在本章，首先要讨论的是 VK_KHR_surface. 它对外暴露了一个 VkSurfaceKHR 的对象,其代表的是一个呈现渲染结果的抽象概念，在我们的程序中，这个表面的后端是通过GLFW打开的窗口。

这个 VK_KHR_surface 是一个实例级的扩展，实际上我们已经启用它了，因为它的名字被包含在 glfwGetRequiredInstanceExtensions 返回的列表中.这个列表还包含了其他的WSI扩展，我们会在稍后使用到。

窗口表面需要在实例创建之后被创建出来，因为它可以影响到物理设备的选择，我们推迟到现在才介绍这个主题，是因为渲染目标和呈现渲染结果是一个庞大的主题，会让之前的基础安装章节显得过于杂乱。也应当注意到,窗口表面对 Vulkan来说是一个完全可选的组件,如果你仅需要离屏渲染的功能，Vukan就不必像OpenGL那样再创建一个不可见的窗口了。

### 窗口表面的创建

首先在调试对象回调的下面新增一个 surface 成员类

```c++
VkSurfaceKHR surface;
```

尽管 VkSurfaceKHR 对象它的使用是平台无关的，但是它的创建却不是这样的，因为创建时需要依赖操作系统窗口的许多细节处理,例如在 Windows 中，需要 HWND 和 HMODULE 句柄，因此需要一个平台相关的扩展，在Windows上叫做 VK_KHR_win32_surface,这个也是自动被包含在glfwGetRequiredInstanceExtensions 返回的列表中。


我将展示如何在Windows上使用特定平台的扩展去创建表面,但并不会在教程中实际去使用它，没有必要在使用了GLFW库的情况下再去编写平台相关的处理代码，GLFW库提供了 glfwCreateWindowSurface 来帮助我们处理平台之间的差异性。虽然这么说，但在我们开始前使用它之前，还是需要了解背后的原理。 

为了访问平台原生的函数，你需要更新以下顶部头文件:

```c++
#define VK_USE_PLATFORM_WIN32_KHR
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#define GLFW_EXPOSE_NATIVE_WIN32
#include <GLFW/glfw3native.h>
```

因为surface是一个Vulkan对象, 需要在创建时填写结构体 VkWin32SurfaceCreateInfoKHR，其有两个重要的参数,hwnd 和 hinstance,它们是窗口及进程的句柄。

```c++
VkWin32SurfaceCreateInfoKHR createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
createInfo.hwnd = glfwGetWin32Window(window);
createInfo.hinstance = GetModuleHandle(nullptr);
```

glfwGetWin32Window 函数用于从GLFW的window中获取最原始的句柄。GetModuleHandle 函数的返回当前的进程句柄。

在这之后 surface 就可以通过vkCreateWin32SurfaceKHR被创建了,这个函数包含的参数有实例,创建的信息,自定义的分配器和用于接收创建对象的返回值.尽管这是一个 WSI的扩展，但因为它太常用了，所以Vulkan会在载入时候直接包含它，不必像其他扩展函数一样再显示的去载入它。

```c++
if (vkCreateWin32SurfaceKHR(instance, &createInfo, nullptr, &surface) != VK_SUCCESS) {
    throw std::runtime_error("failed to create window surface!");
}
```

在其他平台，例如Linux上，处理过程也是类似的。vkCreateXcbSurfaceKHR 会使用xcb连接和窗口，它们都是基于X11 （libx11）来创建出来的。

glfwCreateWindowSurface 函数屏蔽了不同平台间的差异，我们现在将它引入到我们的程序中来，添加一个 createSurface 函数，在initVulkan中，instance创建后调用它.

```c++
void initVulkan(){
    createInstance();
    setupDebugMessenger();
    createSurface();

    pickPhysicalDevice();
    createLogicalDevice();
}

void createSurface() {

}
```

GLFW 的函数接收更简单的参数，而不是结构体，createSurface的实现更加简单。

```C++
void createSurface() {
    if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
        throw std::runtime_error("failed to create window surface!");
    }
}
```

参数分别是 实例对象，GLFW创建出的窗口,自定义的分配器以及一个指向VkSurfaceKHR的指针,它只传递对应平台的调用运行结果。GLFW并没有提供一个专用的销毁surface的函数，因为这个操作Vulkan原始API就可以直接实现。

```c++
void cleanup(){
     ...
    vkDestroySurfaceKHR(instance, surface, nullptr);
    vkDestroyInstance(instance, nullptr);
    ...
}
```

确保surface在 instance之前被销毁。


### 查询呈现操作关联的信息

尽管Vulkan实现了对窗口系统的集成，但这并不意味着每一个设备都支持。因此我们需要扩展 isDeviceSuitable 函数,去确保设备可以把我们创建出的图像显示到窗口上,由于呈现功能是与队列相关的属性，所以现在的问题就变成了，我们需要找到一个支持呈现功能可以将内容显示到表面上的队列簇。

的确有可能，队列簇提供绘制指令，但却不支持显示到surface。因此我们必须考虑到要最呈现层的队列做出区分,修改QueueFamilyIndices 结构体

```C++
struct QueueFamilyIndices{
    std::optional<uint32_t> graphicsFamily;
    std::optional<uint32_t> presentFamily;

    bool isComplete() {
        return graphicsFamily.has_value() && presentFamily.has_value();
    }
};
```

下一步，要修改findQueueFamilies 函数，去找到一个可以将图像呈现到我们创建的表面的队列簇,利用函数 vkGetPhysicalDeviceSurfaceSupportKHR ，它接收的参数是，物理设备，队列簇索引，surface表面，最后的参数返回是否支持，在与查询图形支持的循环中调用它。

```C++
VkBool32 presentMode = false;
vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentMode);
```

检查返回的布尔值，存储支持显示的队列簇索引。

```C++
if(presentSupport){
    indices.presentFamily = i;
}
```

注意，可能最终我们会得到相同的队列簇，可我们为了保持统一的处理方式，程序中总是把它当作单独的队列来处理。尽管如此,你可以显示的假定物理设备就是同时支持图形渲染和显示命令的，从而提高效率。

### 创建呈现队列

接下来，在创建逻辑设备的时候，设置其也创建出一个呈现队列，并使用 VkQueue 句柄来保存它.新增一个成员变量

```C++
VkQueue presentQueue;
```

接着，需要有多个 VkDeviceQueueCreateInfo 结构体，用来创建不同队列簇对应的队列，一个较为优雅的方式是为队列簇创建一个集合，并用此集合去创建队列:

```C++
#include <set>
...

QueueFamilyIndices indices = findQueueFamily(physicalDevice);

std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
std::set<uint32_t> uniqueQueueFamilies = {indices.graphicsFamily.value(),indices.presentFamily.value()};

float queueProprity = 1.0f;
for(uint32_t queueFamily : uniqueQueueFamilies){
    VkDeviceQueueCreateInfo queueCreateInfo{};
    queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queueCreateInfo.queueFamilyIndex = queueFamily;
    queueCreateInfo.queueCount = 1;
    queueCreateInfo.pQueuePriorities = &queuePriority;
    queueCreateInfos.push_back(queueCreateInfo);
}
```

修改 VkDeviceCreateInfo 的信息，指向上面创建出的 queueCreateInfos 容器。

```C++
createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
createInfo.pQueueCreateInfos = queueCreateInfos.data();
```

如果队列簇相同，只需要传递一次它的索引，最后增加调用去接收队列句柄

```C++
vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &presentQueue);
```

在队列簇相同的情况下，这两个队列句柄其实是同一个。在下一章，我们会研究交换链，看到它是怎样将图像显示到表面上的。

## 交换链

Vulkan并没有默认帧缓冲区的概念，因此需要这样的基础设施，它拥有这样的缓冲区接收我们提交的渲染结果，这个基础设施就是交换链，在Vulkan中它必须被显式地创建。交换链地本质，是一队等待被显示到屏幕上地图像，我们的应用程序会从交换链请求一张图像，在上面进行绘制，在绘制完成后返还给队列。怎样让这个队列正确的工作，如何从队列中显示出图像，这依赖于交换链是如何被创建的。通常交换链用于同步要呈现的图像与屏幕刷新率

### 检查交换链的支持

并不是所有的显卡都支持将图像直接显示到屏幕上，例如服务端设备或者没用输出的外设，另外图像的呈现也重度依赖于图形系统和用于显示的窗口，这也并不是Vulkan的核心，所以在查询完设备的支持后你必须启用 VK_KHR_swapchain 设备扩展。

因此我们首先完善 isDeviceSuitable 函数，检查这个扩展是否支持，之前已经看到如何通过 VkPhysicalDevice 列出支持的扩展，所以做法很简单。注意Vulkan 的头文件提供了一个宏 VK_KHR_SWAPCHAIN_EXTENSION_NAME 定义为 "VK_KHR_swapchain",防止拼写上的错误。

首先定义一个需要的设备扩展列表，与打开验证层的方式类似。

```C++
const std::vector<const char *> deviceExtensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
};
```

接下来，创建一个新函数 checkDeviceExtensionSupport(), 它在 isDeviceSuitable 中被调用，实现一个附件的检查。

```C++
bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    bool extensionsSupported = checkDeviceExtensionSupport(device);
    return indices.isComplete() && extensionsSupported;
}

bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
    return true;
}
```

修改函数体，列出所有的设备扩展，检查请求的这个扩展是否在列表中。

```C++
bool checkDeviceExtensionSupport(VkPhysicalDevice device){
    uint32_t extensionCount;
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);

    std::vector<VkExtensionProperties> availableExtensions(extensionCount);
    vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data());

    std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

    for (const auto& extension : availableExtensions) {
        requiredExtensions.erase(extension.extensionName);
    }

    return requiredExtensions.empty();
}
```

我们这里选择一个字符串集去代表要请求的还未被确认的扩展，它可以很容易地当被列出可用扩展后被剔除掉，当然也可以像 checkValidationLayerSupport 里面一样，使用双层循环来判断，在性能上并没有多大差异，现在可以运行你的代码，去验证你显卡的确可以创建交换链。需要注意，其实我们在前一章，已经检查了呈现队列可用，这会隐式的指出创建交换链的扩展也是可用的，然而显式地检测扩展是否支持，一直是个好地习惯。

### 打开设备扩展

创建交换链，首先需要打开 VK_KHR_swapchain ，这仅需要在逻辑设备创建时，做一个小的修改

```C++
createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size());
createInfo.ppEnabledExtensionNames = deviceExtensions.data();
```

确保替换之前的 ``` createInfo.enabledExtensionCount = 0; ```.

### 查询支持的交换链细节信息

只检查交换链是否可用还不够，也许它并不能真正和窗口兼容。创建交换链涉及到的东西也会比 instance 和 device 更多，所以在创建之前，我们还需要查询更多的细节数据。

我们需要检测基础的三种属性:

- 交换链的基础能力 (最大/最小的交换链图像数量, 图像的最大/最小宽高)
- 表面格式 (像素格式，颜色空间)
- 可用的呈现模式
  
与 findQueueFamilies 类似，我们需要一个结构体去接收这些查询到的信息，在结构体里声明出上面提到的三个属性类型。

```C++
struct SwapChainSupportDetails{
    VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};
```

创建新的函数 querySwapChainSupport,用于填充这个查询的结构体.

```C++
SwapChainSupportDetails querySwapChainSupport(){
    SwapChainSupportDetails details;

    return details;
}

```

本章会介绍如何查询这些细节数据，这些结构体包含的数据的含义，会在下一章说明。

首先，我们来看基础的surface能力查询，这些属性很容易查询到，并通过一个 VkSurfaceCapabilitiesKHR 结构体返回

```C++
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities);
```

