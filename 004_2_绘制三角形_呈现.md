# 呈现

## 窗口表面

由于Vulkan 是一个平台无关的API，它本身并没有提供与窗口直接交互的接口，为了建立窗口与Vulkan的连接以将最终的渲染结果呈现到屏幕上,我们需要使用WSI扩展(窗口集成系统),在本章，首先要讨论的是 VK_KHR_surface. 它对外暴露了一个 VkSurfaceKHR 的对象,其代表的是一个呈现渲染结果的抽象概念，在我们的程序中，这个表面的后端是通过GLFW打开的窗口。

这个 VK_KHR_surface 是一个实例级的扩展，实际上我们已经启用它了，因为它的名字被包含在 glfwGetRequiredInstanceExtensions 返回的列表中.这个列表还包含了其他的WSI扩展，我们会在稍后使用到。

窗口表面需要在实例创建之后被创建出来，因为它可以影响到物理设备的选择，我们推迟到现在才介绍这个主题，是因为渲染目标和呈现渲染结果是一个庞大的主题，会让之前的基础安装章节显得过于杂乱。也应当注意到,窗口表面对 Vulkan来说是一个完全可选的组件,如果你仅需要离屏渲染的功能，Vukan就不必像OpenGL那样再创建一个不可见的窗口了。

### 窗口表面的创建

首先在调试对象回调的下面新增一个 surface 成员类

```c++
VkSurfaceKHR surface;
```

尽管 VkSurfaceKHR 对象它的使用是平台无关的，但是它的创建却不是这样的，因为创建时需要依赖操作系统窗口的许多细节处理,例如在 Windows 中，需要 HWND 和 HMODULE 句柄，因此需要一个平台相关的扩展，在Windows上叫做 VK_KHR_win32_surface,这个也是自动被包含在glfwGetRequiredInstanceExtensions 返回的列表中。


我将展示如何在Windows上使用特定平台的扩展去创建表面,但并不会在教程中实际去使用它，没有必要在使用了GLFW库的情况下再去编写平台相关的处理代码，GLFW库提供了 glfwCreateWindowSurface 来帮助我们处理平台之间的差异性。虽然这么说，但在我们开始前使用它之前，还是需要了解背后的原理。 

为了访问平台原生的函数，你需要更新以下顶部头文件的包含:

```c++
#define VK_USE_PLATFORM_WIN32_KHR
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#define GLFW_EXPOSE_NATIVE_WIN32
#include <GLFW/glfw3native.h>
```

