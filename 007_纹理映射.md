# 纹理映射

## 图像 

### 介绍

现在几何体，已经被逐个顶点地设置了颜色,但这是一个相当受限的方案.在本章教程中我们会去实现纹理的映射从而让几何体看起来更加的有趣.这将帮助我们在未来的章节中去导入基础的3D模型。

要为程序添加纹理涉及到以下几个步骤:

- 基于设备内存创建一张图像
- 使用文件中读取出的像素点来填充它
- 创建一个图像采样器
- 添加一个包含了图像采样器的描述符可以从纹理中进行采样
  
我们已经在前面与图像对象打过交道了,不过之前的图像是我们通过交换链拓展自动获取到的。这一次我们会自己创建图像,创建一幅图像并用数据填充它这与顶点缓冲区的创建时类似的，我们首先创建出一个临时资源，用像素数据来填充它，然后我们拷贝这个临时对象到最终的图像对象中,最终的图像对象就是我们会在渲染中使用的。尽管也可以创建一个临时的图像，Vulkan也允许拷贝像素点到临时的图像中,并且这个API在一些硬件上也的确效率很高.但是这里我们首先创建缓冲区并用像素去填充它,然后我们再创建一幅图像用于拷贝这些像素点.这涉及到内存种类的查询，设备内存的分配与绑定。

然而针对图像，也有一些额外的处理,图像有不同的布局会影响到像素在内存中如何被组织.由于硬件的工作方式，简单的一行一行的存储并不是最高效的,例如,当在图像上要实现一些操作时,必须确保他们有与此操作对应的最适合的布局，实际上我们已经在渲染通道中接触过一些布局了.

- VK_IMAGE_LAYOUT_PRESENT_SRC_KHR : 最适合显式
- VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL : 适合从片段着色器写入颜色附件
- VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL : 在传输操作中适合作为一个源，例如 vkCmdCopyImageToBuffer
- VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL : 适合作为传输操作中的目的地,例如 vkCmdCopyBufferToImage
- VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL : 适合用作着色器中的采样
  
一个转换图像布局最常用的方式是管线屏障(pipeline barrier),管线屏障主要用于同步资源的访问,例如确保一个图像在其读取之前已经被写入了,不过这里也可以被用于布局转换.本章会演示如何使用管线屏障完成转换.管线屏障也可以对那些使用了 VK_SHARING_MODE_EXCLUSIVE 模式的队列簇进行传输操作.

### 图片解析库

有许多三方库可以用于图片的加载,你甚至可以自己实现一个解析bmp或者PPM格式的图片解析器.本教程中我们使用 stb_image库,这个库的优点是所有代码都在一个单文件中，不需要复杂的配置,直接下载并存储到一个方便的位置即可,然后将路径加入到include搜索目录中.

### 载入图片

像下面这样包含这个图片库:

```C++
#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
```

头文件仅定义了函数的原型,代码文件需要包含宏 STB_IMAGE_IMPLEMENTATION 与头文件,其中包含了完整的函数体代码,否则会在链接时报错。

```C++
void initVulkan() {
    ...
    createCommandPool();
    createTextureImage();
    createVertexBuffer();
    ...
}

...

void createTextureImage() {

}
```

创建新函数 createTextureImage,我们会在这个函数中完成图片的载入并将图片上传给Vulkan图像对象,我们将要使用命令缓冲，所以它的调用实在createCommandPool之后.

在shader目录下面再创建一个 texture目录,用来存储纹理文件,我们准备载入一张名为 texture.jpg 的纹理文件,此图片的大小是 512 x 512 ，不过这里你可以换成任何你想要的图片,stb_image库支持主流的图片格式如jpg,png,bmp,gif.

使用这个库导入图片十分简单:

```C++
void createTextureImage(){
    int texWidth, texHeight, texChannels;
    stbi_uc* pixels = stbi_load("textures/texture.jpg", 
                        &texWidth, &texHeight, 
                        &texChannels, STBI_rgb_alpha);
    VkDeviceSize imageSize = texWidth * texHeight * 4;
    if(!pixels){
        throw std::runtime_error("failed to load texture image!");
    }
}
```

stbi_load 函数接收文件的路径以及通道数量为参数,STBI_rgb_alpha强制让图片在载入时拥有一个透明度的通道,哪怕图片本身没有透明度通道,这可以让未来我们对其它纹理的处理保持统一,中间的三个参数是输出的宽，高以及实际的通道数量,返回的指针代表像素数组的第一个元素的地址,像素数组按照每个像素点4个字节方式一行一行完成布局,总的数量为 ```texWidth * texHeight * 4```

### 暂存缓冲区

现在可以在CPU可见的内存中创建一个缓冲区，以便于我们使用 vkMapMemory 将像素数据拷贝进去,在createTextureImage函数中添加临时缓冲区变量.

```C++
VkBuffer stagingBuffer;
VkDeviceMemory stagingBufferMemory;
```

缓冲区需要是主机内存可见的以便于我们可以映射它,并且它还需要作为一个传输操作的传输源，以便于我们后面可以将它传输到图像（image）中:

```C++
createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, 
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT  | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT );
```

现在可以直接将像素数据拷贝到缓冲区了 

```C++
void *data;
vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &data);
    memcpy(data, pixels, static_cast<size_t>(imageSize));
vkUnmapMemory(device, stagingBufferMemory);
```

完成后不要忘记清理调原始的像素数据

```C++
stbi_image_free(pixels);
```

### 纹理图像

尽管我们可以让着色器去访问在缓冲区里的像素值,但是更好的方案是使用图像对象(image object).图像对象可以更快更高效地从2D坐标系中查询颜色数据,一个图像中的像素数据被称为纹素(texels),新增下面的两个类成员:

```C++
VkImage textureImage;
VkDeviceMemory textureImageMemory;
```

图像的参数在结构体 VkImageCreateInfo 中被指定:

```C++
VkImageCreateInfo imageInfo{};
imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
imageInfo.imageType = VK_IMAGE_TYPE_2D;
imageInfo.extent.width = static_cast<uint32_t>(texWidth);
imageInfo.extent.height = static_cast<uint32_t>(texHeight);
imageInfo.extent.depth = 1;
imageInfo.mipLevels = 1;
imageInfo.arrayLayers = 1;
```

imageType 字段告诉Vulkan使用哪种坐标系统访问纹素,有可能是1D,2D或者3D的,一维的图像数据可用于存储数组对象或者梯度数据,二维图像主要被用于纹理，三维的图像可用于存储体素,extent字段指定了图像的范围大小,每个轴上有多少个纹素,所以这里的深度(depth)是1而不是0,我们的纹理并不是一个数组，所以这里并不需要使用多级纹理.

```C++
imageInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
```

Vulkan支持许多图像格式,但我们应该使用与像素一样的格式，否则拷贝的操作会失败。

```C++
imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
```

tiling 字段有以下两个取值:

- VK_IMAGE_TILING_LINEAR : 纹素像像素数组一样以行为主序进行布局
- VK_IMAGE_TILING_OPTIMAL : 纹素布局以厂商内部实现为准，通常对GPU友好

与图像的布局不同,tile设定的值之后不可改变.如果你想直接访问图像内存中的数据，必须指定为 VK_IMAGE_TILING_LINEAR 模式,我们将使用临时缓冲区来代替临时图像,所以不需要设置为 LINEAR 模式,使用VK_IMAGE_TILING_OPTIMAL 通常对着色器的访问更加高效。

```C++
imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
```

initialLayout 字段有两个取值:

- VK_IMAGE_LAYOUT_UNDEFINED : GPU无法使用,第一次转换时会舍弃舍弃纹素.
- VK_IMAGE_LAYOUT_PREINITIALIZED : GPU无法使用,但是第一次转换时会保留纹素.
  
有一些场景是有必要在第一次转化的时候保存纹素数据的,例如将图像作为临时图像由CPU写入数据的场景,这里我们使用 VK_IMAGE_LAYOUT_UNDEFINED.

```C++
imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
```

usage字段与缓冲区的usage有相同的语义,图像可用来为缓冲区的拷贝操作作为目的地,我们也需要在着色器中去访问这个图像,所以需要包含 VK_IMAGE_USAGE_SAMPLED_BIT.

```C++
imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
```

这个图像只会被一个队列簇使用,这是一个图形队列同时它也必然支持传输操作.

