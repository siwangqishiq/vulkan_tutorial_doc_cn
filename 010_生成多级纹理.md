# 生成多级纹理

## 介绍

我们的程序现在已经可以导入并渲染3D模型了,在本章,我们会添加一个新的特性,多级纹理的生成。多级纹理被广泛使用于游戏及渲染软件中,并且Vulkan为我们提供了对多级纹理从创建开始的完全控制。

多级纹理是一组预先计算好的,降采样版本的图像,每一个新图像都相较于前一个是宽高尺寸的一半,多级纹理也被称之为LOD(Level Of Detail),对象若是距离摄像机更远，则会采用更小的多级纹理,使用更小的图像会获得更高的渲染速度并避免摩尔纹的产生,多级纹理看上去如下:

![mipmaps_example](imgs/mipmaps_example.jpg)

## 图像创建

在Vulkan中,每一个多级图像都被存储为 不同的 VkImage 的不同级别对象,Mip 等级为0代表原始图像,0之后的级别通常被称之为mip链.

在 vkImage 创建的时候指定 mip 的数量,到目前为止，我们都设置这个值为1,现在我们需要计算图像的维度,首先添加一个成员变量去存储这个数值.

```C++
uint32_t mipLevels;
VkImage textureImage;
```

这个mipLevel的值可以在我们导入纹理资源的时候予以指定:

```C++
int texWidth,texHeight,texChannel;

stbi_uc* pixels = stbi_load(TEXTURE_PATH.c_str(), &texWidth, &texHeight, &texChannels, STBI_rgb_alpha);
...

mipLevels = static_cast<uint32_t>(std::floor(std::log2(std::max(texWidth, texHeight)))) + 1;
```

这会计算出 mip 链的数量,max函数选择出宽高里面更大的值,log2函数则计算出了数值的对数,floor 函数进行四舍五入处理数值若不是2的N次方的情况, +1操作是因为原始图像也占据了一个mip等级( =0 )

为了使用这个值，我们需要去修改 createImage,createImageView,transitionImageLayout 函数,允许我们可以自行指定mip的等级,给这些函数添加一个 mipLevels 的参数.

```C++
void createImage(uint32_t width, 
    uint32_t height, 
    uint32_t mipLevels, 
    VkFormat format, 
    VkImageTiling tiling, 
    VkImageUsageFlags usage, 
    VkMemoryPropertyFlags properties, 
    VkImage& image, 
    VkDeviceMemory& imageMemory){
    
    ...
    imageInfo.mipLevels = mipLevels;
    ...
}
```

```C++
VkImageView createImageView(
    VkImage image, 
    VkFormat format, 
    VkImageAspectFlags aspectFlags, uint32_t mipLevels) {
    ...
    viewInfo.subresourceRange.levelCount = mipLevels;
    ...
```

```C++
void transitionImageLayout(
    VkImage image, 
    VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, uint32_t mipLevels) {
    ...
    barrier.subresourceRange.levelCount = mipLevels;
    ...
```

用正确的值更新所有的这些函数调用

```C++
createImage(swapChainExtent.width, swapChainExtent.height, 1, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);

...

createImage(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);
```

```C++
swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT, 1);
...
depthImageView = createImageView(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT, 1);
...
textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT, mipLevels);
```

```C++
transitionImageLayout(depthImage, depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, 1);
...
transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);
```

## 生成多级纹理

我们的图像现在已经有多个级别,但是暂存缓冲区只可以用来填充层级为0的,其他的层级依然是未被定义的，为了填充这些层级，我们需要从我们已有的单个层级中生成数据,需要使用 vkCmdBlitImage 指令,这个指令可以实现拷贝,缩放,过滤等操作。我们会多次进行这个blit操作以让它为我们的纹理图像生成每一个层级的图像。

vkCmdBlitImage 被用来作为一个传输操作,必须通知vulkan 这个传输操作的源与目的地是一样的,在createImage函数中添加标志位 VK_IMAGE_USAGE_TRANSFER_SRC_BIT :

```C++
...
createImage(texWidth, texHeight, 
    mipLevels, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_TILING_OPTIMAL, 
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);
...
```

就像其他的图像操作一样,vkCmdBlitImage操作依赖于图像的布局,我们需要将整个图像转化为 VK_IMAGE_LAYOUT_GENERAL,但大多数情况下这个转换很慢,为了优化性能,原图像应该是 VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ，并且目标图像应该是 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL，Vulkan允许对每一个层级的图像做单独的转换,每次一个blit操作仅会处理两个关联的层级,所以我们可以将每一个层级转化为优化的布局格式.

transitionImageLayout 函数只会实现整个图像的布局转换,所以这里我们要再添加一些管线屏障命令,移除在 createTextureImage 中已经存在的转换 VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:

```C++
...
transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels);
    copyBufferToImage(stagingBuffer, textureImage, static_cast<uint32_t>(texWidth), static_cast<uint32_t>(texHeight));
//transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps
...
```

这会将每一个层级的纹理图像都仅转换为 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL，每一个层级的纹理图像将会在 blit 操作后被转换为 VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL .

现在可以去实现一个实现了多级纹理的函数了:

```C++
void generateMipmaps(VkImage image, int32_t texWidth, int32_t texHeight, uint32_t mipLevels) {
    VkCommandBuffer commandBuffer = beginSingleTimeCommands();

    VkImageMemoryBarrier barrier{};
    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    barrier.image = image;
    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    barrier.subresourceRange.baseArrayLayer = 0;
    barrier.subresourceRange.layerCount = 1;
    barrier.subresourceRange.levelCount = 1;

    endSingleTimeCommands(commandBuffer);
}
```

我们会做多次的转换,所以这里会重用 VkImageMemoryBarrier,在开头设置这个字段是所有层级都通用的. subresourceRange.miplevel ,oldLayout,newLayout,srcAccessMask 和 dstAccessMask将会在每一个转化中被修改为不同的值。

```C++
int32_t mipWidth = texWidth;
int32_t mipHeight = texHeight;

for (uint32_t i = 1; i < mipLevels; i++) {

}
```

循环会在每一次都记录下 VkCmdBlitImage 命令,注意循环变量是从1开始的.

```C++
barrier.subresourceRange.baseMipLevel = i - 1;
barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

vkCmdPipelineBarrier(commandBuffer,
    VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0,
    0, nullptr,
    0, nullptr,
    1, &barrier);
```

首先我们将层级 i - 1 的图像布局转化为 VK_IMAGR_LAYOUT_SRC_OPTIMAL,这个转换将会等待层级 i-1 被前面的blit命令或者是 vkCmdCopyBufferToImage 填充完，当前的blit命令将会等待这个操作。

```C++
VkImageBlit blit{};
blit.srcOffsets[0] = { 0, 0, 0 };
blit.srcOffsets[1] = { mipWidth, mipHeight, 1 };
blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
blit.srcSubresource.mipLevel = i - 1;
blit.srcSubresource.baseArrayLayer = 0;
blit.srcSubresource.layerCount = 1;

blit.dstOffsets[0] = { 0, 0, 0 };
blit.dstOffsets[1] = { mipWidth > 1 ? mipWidth / 2 : 1, mipHeight > 1 ? mipHeight / 2 : 1, 1 };
blit.dstSubresource.aspectMask = VK_IMAGE_ASPECTX_COLOR_BIT;
blit.dstSubresource.mipLevel = i;
blit.dstSubresource.baseArrayLayer = 0;
blit.dstSubresource.layerCount = 1;

```
接下来，我们指定将要用于 blit操作的范围,源的层级是 i - 1 目标的层级是 i,srcOffsets字段的两个元素指定了将会被 blit的范围,dstOffsets 的两个元素决定了将会被blit的目标位置,X,Y的值

## 线性过滤的支持

## 采样器