# 绘制

## 帧缓冲

前面章节中我们已经提及了很多次关于帧缓冲了，我们设置了渲染通道，并且期望帧缓冲与交换链具有相同的格式,但是我们还没有实际去创建出帧缓冲。

在渲染通道创建时被指定的附件，被绑定到 VkFrameBuffer 对象中.帧缓冲区所引用的 VkImageView 对象，代表着这些附件。我们的例子中只有一个，便是颜色附件。但是这个图像依赖于交换链在呈现时，返回给我们的是那一张图像，这意味着，我们必须为交换链中的所有图像创建出对应的帧缓冲，在绘制时，使用对应的帧缓冲.

创建一个 std::vector 类型的成员变量，存储多个帧缓冲。

```C++
std::vector<VkFrameBuffer> swapChainFrameBuffers;
```

创建新函数 createFramebuffers ，在initVulkan函数创建完渲染管线后调用它：

```C++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
}

...

void createFramebuffers() {

}
```

重置容器的大小，去存储所有的帧缓冲

```C++
void createFramebuffers() {
    swapChainFramebuffers.resize(swapChainImageViews.size());
}
```

然后迭代所有的交换链中的图像，去创建出相同数量的帧缓冲

```C++
for (size_t i = 0; i < swapChainImageViews.size(); i++){
    VkImageView attachments[] = {
        swapChainImageViews[i]
    };

    VkFramebufferCreateInfo framebufferInfo{};
    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebufferInfo.renderPass = renderPass;
    framebufferInfo.attachmentCount = 1;
    framebufferInfo.pAttachments = attachments;
    framebufferInfo.width = swapChainExtent.width;
    framebufferInfo.height = swapChainExtent.height;
    framebufferInfo.layers = 1;

    if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) {
        throw std::runtime_error("failed to create framebuffer!");
    }
}
```

帧缓冲的创建很简单。我们首先指定帧缓冲需要兼容的渲染过程，你只可以使用与这个渲染通道兼容的帧缓冲，兼容的条件可以简单理解为使用了相同类型与数量的附件。

attachmentCount 和 pAttachments 指定了被绑定的 VkImageView 对象，它代表了渲染通道中的附件数组对象。

width 和 height 参数意义很明显，layers 参数代表了图像数组的层数，我们的交换链图像是单个图像，所以这里设置为1 .

需要在结束渲染时，且图像视图与渲染通道销毁前，删除掉帧缓冲

```C++
void cleanup() {
    for (auto framebuffer : swapChainFramebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }

    ...
}
```

现在已经拥有了所有渲染需要的对象了，下一节我们会写下第一个用于实际渲染的命令。

## 命令缓冲区

Vulkan中的命令，例如绘制操作或内存传输，都不是通过函数调用来直接运行的，你必须在命令缓冲中记录所有的操作，好处是，当我们准备好告诉Vulkan 我们想要做什么的时候，所有的命令都被一起提交给了Vulkan,Vulkan可以更加高效地处理这些命令，并且，也允许记录指令的过程用多个线程去并发地记录。

### 命令池

在创建指令缓冲前，我们必须先创建出一个指令池。指令池会管理从它这里分配的指令缓冲，添加一个新的成员变量去存储指令池.

```C++
VkCommandPool commandPool;
```

创建新函数 createCommandPool ，在创建完帧缓冲后调用它

```C++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
}

...

void createCommandPool() {

}
```

命令池的创建仅需要两个参数:

```C++
QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);

VkCommandPoolCreateInfo poolInfo{};
poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();
```

flag值可取以下的两个值

- VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : 提示命令缓冲区会经常被重新记录（也许会改变内存的分配行为）

- VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : 允许命令缓冲被单独重置，没有这个设置，它们会被一起重置。
  
我们会为每一帧记录一个命令缓冲，所以我们想重置和重新记录它,因此我们要为命令池设置 VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT 标志位.

命令缓冲通过提交给设备队列来运行，例如图形队列或呈现队列。每一个命令缓冲池只可以给一种类型的队列分配命令缓冲。我们准备去记录绘制命令，因此在这里选择了图形队列簇的索引填写到 VkCommandPoolCreateInfo 结构体中。

```C++
if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
    throw std::runtime_error("failed to create command pool!");
}
```

最后使用 vkCreateCommandPool 创建出命令池，它并没有什么特殊的参数，创建出的命令会被用于程序中绘制东西到屏幕上,所以命令池仅可以在程序结束时被销毁.

```C++
void cleanup() {
    vkDestroyCommandPool(device, commandPool, nullptr);

    ...
}
```

### 命令缓冲的分配

### 命令缓冲的记录

### 开始一个渲染过程

### 基础的绘制指令

### 完成

## 渲染与呈现

## 帧的并行渲染