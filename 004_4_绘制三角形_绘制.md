# 绘制

## 帧缓冲

前面章节中我们已经提及了很多次关于帧缓冲了，我们设置了渲染通道，并且期望帧缓冲与交换链具有相同的格式,但是我们还没有实际去创建出帧缓冲。

在渲染通道创建时被指定的附件，被绑定到 VkFrameBuffer 对象中.帧缓冲区所引用的 VkImageView 对象，代表着这些附件。我们的例子中只有一个，便是颜色附件。但是这个图像依赖于交换链在呈现时，返回给我们的是那一张图像，这意味着，我们必须为交换链中的所有图像创建出对应的帧缓冲，在绘制时，使用对应的帧缓冲.

创建一个 std::vector 类型的成员变量，存储多个帧缓冲。

```C++
std::vector<VkFrameBuffer> swapChainFrameBuffers;
```

创建新函数 createFramebuffers ，在initVulkan函数创建完渲染管线后调用它：

```C++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
}

...

void createFramebuffers() {

}
```

重置容器的大小，去存储所有的帧缓冲

```C++
void createFramebuffers() {
    swapChainFramebuffers.resize(swapChainImageViews.size());
}
```

然后迭代所有的交换链中的图像，去创建出相同数量的帧缓冲

```C++
for (size_t i = 0; i < swapChainImageViews.size(); i++){
    VkImageView attachments[] = {
        swapChainImageViews[i]
    };

    VkFramebufferCreateInfo framebufferInfo{};
    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    framebufferInfo.renderPass = renderPass;
    framebufferInfo.attachmentCount = 1;
    framebufferInfo.pAttachments = attachments;
    framebufferInfo.width = swapChainExtent.width;
    framebufferInfo.height = swapChainExtent.height;
    framebufferInfo.layers = 1;

    if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) {
        throw std::runtime_error("failed to create framebuffer!");
    }
}
```

帧缓冲的创建很简单。我们首先指定帧缓冲需要兼容的渲染过程，你只可以使用与这个渲染通道兼容的帧缓冲，兼容的条件可以简单理解为使用了相同类型与数量的附件。

attachmentCount 和 pAttachments 指定了被绑定的 VkImageView 对象，它代表了渲染通道中的附件数组对象。

width 和 height 参数意义很明显，layers 参数代表了图像数组的层数，我们的交换链图像是单个图像，所以这里设置为1 .

需要在结束渲染时，且图像视图与渲染通道销毁前，删除掉帧缓冲

```C++
void cleanup() {
    for (auto framebuffer : swapChainFramebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }

    ...
}
```

现在已经拥有了所有渲染需要的对象了，下一节我们会写下第一个用于实际渲染的命令。

## 命令缓冲区

Vulkan中的命令，例如绘制操作或内存传输，都不是通过函数调用来直接运行的，你必须在命令缓冲中记录所有的操作，好处是，当我们准备好告诉Vulkan 我们想要做什么的时候，所有的命令都被一起提交给了Vulkan,Vulkan可以更加高效地处理这些命令，并且，也允许记录指令的过程用多个线程去并发地记录。

### 命令池

在创建指令缓冲前，我们必须先创建出一个指令池。指令池会管理从它这里分配的指令缓冲，添加一个新的成员变量去存储指令池.

```C++
VkCommandPool commandPool;
```

创建新函数 createCommandPool ，在创建完帧缓冲后调用它

```C++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
}

...

void createCommandPool() {

}
```

命令池的创建仅需要两个参数:

```C++
QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);

VkCommandPoolCreateInfo poolInfo{};
poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();
```

flag值可取以下的两个值

- VK_COMMAND_POOL_CREATE_TRANSIENT_BIT : 提示命令缓冲区会经常被重新记录（也许会改变内存的分配行为）

- VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT : 允许命令缓冲被单独重置，没有这个设置，它们会被一起重置。
  
我们会为每一帧记录一个命令缓冲，所以我们想重置和重新记录它,因此我们要为命令池设置 VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT 标志位.

命令缓冲通过提交给设备队列来运行，例如图形队列或呈现队列。每一个命令缓冲池只可以给一种类型的队列分配命令缓冲。我们准备去记录绘制命令，因此在这里选择了图形队列簇的索引填写到 VkCommandPoolCreateInfo 结构体中。

```C++
if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
    throw std::runtime_error("failed to create command pool!");
}
```

最后使用 vkCreateCommandPool 创建出命令池，它并没有什么特殊的参数，创建出的命令会被用于程序中绘制东西到屏幕上,所以命令池仅可以在程序结束时被销毁.

```C++
void cleanup() {
    vkDestroyCommandPool(device, commandPool, nullptr);

    ...
}
```

### 命令缓冲的分配

现在开始分配命令缓冲.

类成员中创建一个 VkCommandBuffer 对象.命令缓冲会在命令池被销毁时自动清理，所以不需要在 cleanup 中显式清理了。

```C++
VkCommandBuffer commandBuffer;
```

创建 createCommandBuffer 函数，从命令池中新建出命令缓冲。

```C++
void initVulkan(){
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createRenderPass();
    createGraphicsPipeline();
    createFramebuffers();
    createCommandPool();
    createCommandBuffer();
}

...

void createCommandBuffer() {

}
```

命令缓冲通过 vkAllocateCommandBuffers 函数进行分配，它接收一个 VkCommandBufferAllocateInfo 参数，用于指定从哪个命令池分配及需要分配多少个命令缓冲:

```C++
VkCommandBufferAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
allocInfo.commandPool = commandPool;
allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
allocInfo.commandBufferCount = 1;

if (vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer) != VK_SUCCESS) {
    throw std::runtime_error("failed to allocate command buffers!");
}
```

level 参数指明，分配的命令缓冲是主缓冲还是次级缓冲。

- VK_COMMAND_BUFFER_LEVEL_PRIMARY : 可以被提交给队列直接运行，但是不能从其他命令缓冲中调用。
- VK_COMMAND_BUFFER_LEVEL_SECONDARY : 不可以被直接提交，但是可以从主缓冲中被调用。

我们这里不会使用次级缓冲队列，但是这里从主缓冲中复用常用操作是很有用的。

因为我们只分配了一个命令缓冲，这里commandBufferCount 设置为 1.

### 命令缓冲的录制

现在在函数 recordCommandBuffer 中完成写入命令到命令缓冲的工作，要被写入的 VkCommandBuffer 会作为一个参数传入，同时，交换链的图像索引，也会当成参数传入。

```C++
void recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex){

}
```

开始命令缓冲的录制，我们总是以 vkBeginCommandBuffer 调用开始,它使用 VkCommandBufferBeginInfo 作为参数,其中包含了一些使用命令缓冲的细节。

```C++
VkCommandBufferBeginInfo beginInfo{};
beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
beginInfo.flags = 0; // Optional
beginInfo.pInheritanceInfo = nullptr; // Optional

if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
    throw std::runtime_error("failed to begin recording command buffer!");
}
```

flags 参数指定了我们希望怎样去使用命令缓冲，可以有以下取值：

- VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT ： 表示命令只会被提交一次
- VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT : 该命令缓冲区将会作为一个次级命令缓冲区,用于渲染通道的一个子过程。 
- VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT : 允许命令缓冲区在多个队列提交中并发使用。

这些标志目前我们都用不上。

pInheritanceInfo 参数仅与次级命令缓冲区相关,它指定了从主命令缓冲区继承哪个状态。

如果命令缓冲已经被记录了一次了，再次调用 vkBeginCommandBuffer ，将会隐式地重置它，不可能在命令缓冲中再继续添加命令。

### 开始一个渲染过程

通过 vkCmdBeginRenderPass 开始绘制过程。填写结构体 VkRenderPassBeginInfo 。

```C++
VkRenderPassBeginInfo renderPassInfo{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
renderPassInfo.renderPass = renderPass;
renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];
```

第一个参数是渲染通道自身，以及它所绑定的附件。我们为交换链的每一个图像都创建了帧缓冲，它在这里被指定为颜色附件。因此我们需要给想要绘制的图像绑定帧缓冲。使用传递进来的图像索引参数，可以让我们选择出正确的当前正在使用的帧缓冲。

```C++
renderPassInfo.renderArea.offset = {0, 0};
renderPassInfo.renderArea.extent = swapChainExtent;
```

接下来的两个参数，定义了渲染区域的大小。此区域之外的像素点，值是未定义的。需要匹配附件的大小以获得最佳的效能。

```C++
VkClearValue clearColor = {{{0.0f, 0.0f, 0.0f, 1.0f}}};
renderPassInfo.clearValueCount = 1;
renderPassInfo.pClearValues = &clearColor;
```

最后的两个参数定义了,使用 VK_ATTACHMENT_LOAD_OP_CLEAR 设置时，在载入时候需要的清理颜色,会在清理颜色附件时使用到，这里定义清除的颜色为不透明的黑色。

```C++
vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
```

渲染通道现在可以开始了，所有在命令缓冲中被记录的函数调用都以 vkCmd 为开头，它们的返回值都是空的，所以这里并没有错误处理，直到我们结束录制。

第一个参数是需要被记录的命令缓冲，第二个参数指定了渲染过程的细节。第三个参数指定了绘制命令如何被提供，它有两个取值:

- VK_SUBPASS_CONTENTS_INLINE : 渲染通道中的命令会嵌入到主命令缓冲区，没有次级缓冲区被运行。
- VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS : 渲染通道的命令可以从次级缓冲区运行。

我们并不使用次级缓冲区，所以这里选第一个。

### 基础的绘制指令

现在可以绑定图形管线了 

```C++
vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
```

第二个参数指定是图形管线还是计算管线。我们现在已经告诉了 Vulkan,在图形管线中运行什么样的操作，在片段着色器中使用哪一个附件。

在管线固定功能一节中，已经说过，我们必须动态指定视口和裁剪状态,所以在绘制命令前，需要设置这两个状态.

```C++
VkViewport viewport{};
viewport.x = 0.0f;
viewport.y = 0.0f;
viewport.width = static_cast<float>(swapChainExtent.width);
viewport.height = static_cast<float>(swapChainExtent.height);
viewport.minDepth = 0.0f;
viewport.maxDepth = 1.0f;
vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

VkRect2D scissor{};
scissor.offset = {0, 0};
scissor.extent = swapChainExtent;
vkCmdSetScissor(commandBuffer, 0, 1, &scissor);
```

现在可以发出真正的三角形的绘制命令了

```C++
vkCmdDraw(commandBuffer, 3, 1, 0, 0);
```


### 完成

## 渲染与呈现

## 帧的并行渲染
