# 统一缓冲区

## 布局描述符与缓冲区

### 介绍

我们现在可以为每个顶点传递各种各样的属性,可是，应该如何处理全局变量呢?我们准备在这一章进入3D图形的领域,现在需要一个 Model - View - Project 矩阵,可以在顶点属性中去包含它,但是这太过浪费内存了,而且当需要变换矩阵时，就需要更新顶点缓冲区,而这样的转换在每一帧都有可能发生.

Vulkan中处理这个场景的正确方法是使用资源描述符.描述符是一种可以让着色器自由地访问资源的方法,我们将会去安装一个包含了变换矩阵的缓冲区,并且让顶点着色器可以通过描述符访问矩阵.描述符的使用包含三部分:

- 在管线创建时指定一个描述符集合的布局(descriptor set layout)
- 从描述符池中分配描述符集合
- 在渲染时绑定描述符

描述符集合布局指定了管线访问时资源的布局，就像渲染通道指定了附件的类型一样,一个描述符集合指定了实际的缓冲区或者图像资源,就像帧缓冲区指定了真正的绑定到渲染通道附件的图像资源一样,描述符集也会被绑定到绘制命令中，就像顶点缓冲区和帧缓冲.

有许多类型的描述符,但是在本章，我们使用统一变量缓冲区(UBO),会在后面看到其他类型的描述符,但是处理起来是一样的,现在创建C的一个结构体，此结构体包含了三个变换矩阵.

```C++
struct UniformBufferObject {
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
```

然后我们可以拷贝数据到VkBuffer中,然后在顶点着色器中通过一个统一缓冲区对象来访问它:

```C++
layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

void main(){
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0f ,1.0f);
    fragColor = inColor;
}
```

我们将在每一帧去更新 模型，视图，透视矩阵,以让前一章的矩形绕固定轴旋转。

### 顶点着色器

像上面提到的那样，修改顶点着色器让它包含统一变量缓冲区,我们假定你熟悉 MVP 矩阵变换

```glsl
#version 450
layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

layout(location = 0) in vec2 inPosition;
layout(location = 1) in vec3 inColor;

layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
```

注意一下 uniform 的顺序,in 和 out 的申明是没有关系的.binding代表的意义与location代表的属性是相似的，我们会在绑定描述符集中引用这个 binding . gl_Position 这一行修改成矩阵乘法去计算出最终的屏幕裁剪坐标系坐标,与2D三角形不同，最后一个参数可能不是1，这将会导致坐标值被除以最后一个分量，以最终适配标准归一化的屏幕坐标,这被使用在投影矩阵中，作为投影切割，它是产生近大远小效果的核心。

### 描述符集合布局

下一步是在C++侧定义UBO，告诉Vulkan在顶点着色器中的描述.

```C++
struct UniformBufferObject {
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
```

我们可以使用 GLM 库中的数据类型完美匹配glsl中的类型,矩阵的数据是在二进制层面兼容的，所以我们可以使用memcpy拷贝 UniformBufferObject 到 VkBuffer 中.

需要在管线创建时提供每一个描述符绑定的细节,就像我们为每个顶点属性定义的一样,创建 createDescriptorSetLayout 来定义所有的这些信息.由于在创建管线时需要使用，所以应该在管线创建前调用这个函数.

```C++
void initVulkan() {
    ...
    createDescriptorSetLayout();
    createGraphicsPipeline();
    ...
}

...

void createDescriptorSetLayout() {

}
```

每一个绑定点都需要通过 VkDescriptorSetLayoutBinding 结构体来描述.

```C++
void createDescriptorSetLayout(){
    VkDescriptorSetLayoutBinding uboLayoutBinding{};
    uboLayoutBinding.binding = 0;
    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    uboLayoutBinding.descriptorCount = 1;
}
```

前两个参数指定了在着色器中使用的绑定点以及描述符的类型,是一个统一变量，有可能使用一个数组来代表统一缓冲区变量,descriptorCount 指定了这个数组的元素个数,可以用于在骨骼动画中指定每一个骨骼的变换,我们这里的 MVP 变换只有一个单个的统一缓冲区变量,所以这里count 设置为1.

```C++
uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
```

也需要指定描述符用于着色的哪一个阶段,stageFlags 可以使用 VkShaderStageFlagBits 变量的集合|,或者直接使用 VK_SHADER_STAGE_ALL_GRAPHICS,在本例中，我们只在顶点着色器中使用此描述符.

```C++
uboLayoutBinding.pImmutableSamplers = nullptr; // Optional
```

pImmutableSamplers 字段与图像采样有关，后面会介绍.

所有的描述符绑定对象都被合并到一个 VkDescriptorSetLayout 对象中,在 pipelineLayout 之前定义一个新的成员类.

```C++
VkDescriptorSetLayout descriptorSetLayout;
VkPipelineLayout pipelineLayout;
```

然后使用 vkCreateDescriptorSetLayout 创建它.此函数接收一个 VkDescriptorSetLayoutCreateInfo 结构体承载绑定的描述数组.

```C++
VkDescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
layoutInfo.bindingCount = 1;
layoutInfo.pBindings = &uboLayoutBinding;

if (vkCreateDescriptorSetLayout(device, &layoutInfo, nullptr, &descriptorSetLayout) != VK_SUCCESS) {
    throw std::runtime_error("failed to create descriptor set layout!");
}
```

需要在管线创建的时候指定描述符集,以告诉Vulkan 使用着色器的时候使用哪个描述符，描述符集在管线布局对象中指定,修改 VkPipelineLayoutCreateInfo 引用这个布局对象.

```C++
VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutInfo.setLayoutCount = 1;
pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;
```




### 统一缓冲区

### 更新统一变量数据

## 描述符池与描述符集合
