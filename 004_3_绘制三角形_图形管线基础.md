# 图形管线基础

## 简介

后面的章节，我们将会安装配置一个用于渲染第一个三角形的图形管线。图形管线是一系列有序操作的集合，它获取你提供的网格的顶点和纹理，将其转换为渲染目标上的像素点。下图是一个简单的过程展示

![图形管线](imgs/vulkan_simplified_pipeline.svg)

输入装配阶段 会从你指定的缓冲区收集原始的顶点数据，也许也会使用索引缓冲，以此减少重复顶点的数据量。

顶点着色器 它是逐顶点运行的，通常在顶点着色器中完成顶点位置的转换，将模型坐标转为屏幕坐标。也会将每个顶点的数据传给着色器的下一个阶段。

细分着色器允许你基于确定的规则去细分集合体，从而让网格获得更高的质量。例如其通常用于将砖块台阶这些物体看起来不是那么平坦。

几何着色器被运行在每一个图元上(三角形，线段，点),它可以丢弃这些图元，或者生成更多的图元。这与细分着色器很像，但是更加灵活。但是，大多数应用中并没有用到它，因为它在除Intel之外的显卡上，性能表现不佳。

光栅化阶段，会将之前的图元拍散到片段中.片段是指将会被写入帧缓冲区的像素，任何超出屏幕显示范围的片段都会被丢弃掉，前面顶点着色器的输入，会在片段着色器中被插值。通常，如果片段着色器被其他的片原片段所覆盖，也会因为深度测试被丢弃掉。

片段着色器会被每一个之前步骤存活下来的片段所调用，以决定要像帧缓冲区中写入什么样的颜色值和深度值。它也可以使用从顶点着色器传来经过插值的数据，通常是纹理坐标、光照法线等。

颜色混合会针对映射到相同像素点的片段，执行混合操作，最简单的是覆盖掉原有值，或者增加原始值，抑或是进行透明度混合。

绿色标识出的阶段，被称为固定功能阶段，这些阶段允许你使用参数调整他们的操作，但是这些阶段是预先已经定义好的，不可修改。

另外的黄色标识的阶段是可编程的,这意味着你可以上传自己的代码给显卡，以完成任何你想要的操作。例如，可以使用片段着色器，实现从纹理到照明到光线追踪。。。,这些程序并行运行在许多GPU核上。

如果你之前用过诸如OpenGL或者Direct3D等其他图形API，你可以使用如 glBlendFunc 或者 OMSetBlendState 去修改图形管线的设置.Vulkan中的图形管线几乎是完全不可变的，所以如果你想去修改着色器、绑定不同的帧缓冲、修改混合模式，必须重建图形管线.缺点是你不得不创建大量的管线以代表不同的渲染操作，然而由于所有的管线都提前知晓了，驱动层就可以做更多定制性的优化了。

基于你的需求，有些可编程的阶段是可选的。例如，如果你只想绘制简单的几何图形，细分着色器和几何着色器可以被禁用。如果你仅对深度值感兴趣，可以禁用片段着色，这对于阴影贴图的生成很有用。

在下一章，我们会创建两个对于显示三角形所必须的可编程阶段: 顶点着色器 和 片段着色器。固定功能的设置，例如混合模式，视口变换，光栅化等都会在那之后予以讨论。最后一部分是关于帧缓冲的输入与输出规范。

创建一个 createGraphicsPipeline() 函数,在createImageViews 之后调用。我们整个一章都会在这个函数里进行。

```C++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createGraphicsPipeline();
}

...

void createGraphicsPipeline() {

}
```

下一章会讨论，能真正在屏幕上绘制出内容的着色器模块。

## 着色器模块

## 固定功能

## 渲染通道

## 结论
