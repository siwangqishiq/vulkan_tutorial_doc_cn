# 图形管线基础

## 简介

后面的章节，我们将会安装配置一个用于渲染第一个三角形的图形管线。图形管线是一系列有序操作的集合，它获取你提供的网格的顶点和纹理，将其转换为渲染目标上的像素点。下图是一个简单的过程展示

![图形管线](imgs/vulkan_simplified_pipeline.svg)

输入装配阶段 会从你指定的缓冲区收集原始的顶点数据，也许也会使用索引缓冲，以此减少重复顶点的数据量。

顶点着色器 它是逐顶点运行的，通常在顶点着色器中完成顶点位置的转换，将模型坐标转为屏幕坐标。也会将每个顶点的数据传给着色器的下一个阶段。

细分着色器允许你基于确定的规则去细分集合体，从而让网格获得更高的质量。例如其通常用于将砖块台阶这些物体看起来不是那么平坦。

几何着色器被运行在每一个图元上(三角形，线段，点),它可以丢弃这些图元，或者生成更多的图元。这与细分着色器很像，但是更加灵活。但是，大多数应用中并没有用到它，因为它在除Intel之外的显卡上，性能表现不佳。

光栅化阶段，会将之前的图元拍散到片段中.片段是指将会被写入帧缓冲区的像素，任何超出屏幕显示范围的片段都会被丢弃掉，前面顶点着色器的输入，会在片段着色器中被插值。通常，如果片段着色器被其他的片原片段所覆盖，也会因为深度测试被丢弃掉。

片段着色器会被每一个之前步骤存活下来的片段所调用，以决定要像帧缓冲区中写入什么样的颜色值和深度值。它也可以使用从顶点着色器传来经过插值的数据，通常是纹理坐标、光照法线等。

颜色混合会针对映射到相同像素点的片段，执行混合操作，最简单的是覆盖掉原有值，或者增加原始值，抑或是进行透明度混合。

绿色标识出的阶段，被称为固定功能阶段，这些阶段允许你使用参数调整他们的操作，但是这些阶段是预先已经定义好的，不可修改。

另外的黄色标识的阶段是可编程的,这意味着你可以上传自己的代码给显卡，以完成任何你想要的操作。例如，可以使用片段着色器，实现从纹理到照明到光线追踪。。。,这些程序并行运行在许多GPU核上。

如果你之前用过诸如OpenGL或者Direct3D等其他图形API，你可以使用如 glBlendFunc 或者 OMSetBlendState 去修改图形管线的设置.Vulkan中的图形管线几乎是完全不可变的，所以如果你想去修改着色器、绑定不同的帧缓冲、修改混合模式，必须重建图形管线.缺点是你不得不创建大量的管线以代表不同的渲染操作，然而由于所有的管线都提前知晓了，驱动层就可以做更多定制性的优化了。

基于你的需求，有些可编程的阶段是可选的。例如，如果你只想绘制简单的几何图形，细分着色器和几何着色器可以被禁用。如果你仅对深度值感兴趣，可以禁用片段着色，这对于阴影贴图的生成很有用。

在下一章，我们会创建两个对于显示三角形所必须的可编程阶段: 顶点着色器 和 片段着色器。固定功能的设置，例如混合模式，视口变换，光栅化等都会在那之后予以讨论。最后一部分是关于帧缓冲的输入与输出规范。

创建一个 createGraphicsPipeline() 函数,在createImageViews 之后调用。我们整个一章都会在这个函数里进行。

```C++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createGraphicsPipeline();
}

...

void createGraphicsPipeline() {

}
```

下一章会讨论，能真正在屏幕上绘制出内容的着色器模块。

## 着色器模块

GLSL 与 HLSL都是以文本形式提供着色器代码的，与这些API不同，Vulkan的着色器代码必须以二进制字节码的格式给出。这种格式被称作 SPIR-V，它被设计用于Vulkan 和 OpenCL ，这是一个可以被用于写计算和图像shader的格式，我们在此教程中会聚焦于着色器在图形管线中的应用。

使用比特码的好处是，对GPU生产商来说，实现由着色器代码到本地代码的编译器不会太过复杂。过去的经验表明，人类可读的着色器代码，例如GLSL，对其语义的解释标准是相当灵活的。如果你为一个GPU驱动写了一个着色器程序，在其他GPU上运行，可能会报出一个语法上的错误，或者更糟，由于编译器的bug，你的着色器运行效果是不一样的。直接使用 SPIR-V 格式的二进制码，很可能会避免这些问题。

然而，这并不意味着我们需要手写二进制码。Khronos已经为我们提供了一个独立于厂商的编译器，可以将glsl语言转换为SPIR-V的二进制格式。这个编译器会验证你的shader代码是否符合标准并会生成一个SPIR-V格式的二进制文件。也可以将这个编译器用作一个依赖库，用于在运行时动态生成二进制码，但在此教程中，我们并不会这么做。尽管我们可以直接使用 glslangValidator.exe ,但是这里还是使用谷歌提供的 glslc.exe 来代替。glslc的优势是，可以使用与gcc、Clang这些编译器相同的参数，并且它也包含了一些额外的功能，例如include, 这两个文件都是包含在 Vulkan的SDK中的，我们不必再去额外下载它们了。

GLSL是一个与C语言类似的着色器语言。程序以main函数为入口，与其他程序使用参数作为输入，返回值作为输出不同，着色器程序使用全局变量去处理输入和输出。该语言包含许多特性是为图形程序设计的，例如内建的向量类型 vec*,矩阵类型 mat*，也提供了诸如，向量的叉乘，矩阵向量乘法，求一个向量的反射向量这些操作。向量类型以vec开头，跟上向量的维度,如vec2,vec3,vec4。举个例子，一个3D的位置数据可被存储为vec3,也可以通过.x .y .z 来访问单个成员，也可以从多个成员中创建出一个新的向量，例如,vec3(1.0, 2.0, 3.0).xy 会创建出一个 vec2 类型， 向量构造器也可以结合向量对象和标量值，例如一个vec3类型可以这样构造 vec3(vec2(1.0f , 2.0f) , 3.0f)

前面提到，我们需要实现一个顶点着色器和片段着色器来在屏幕上绘制出一个三角形，后面两章将会介绍着色器代码，在此之后，会展示怎样生成SPIR-V字节码，并将它们导入到程序中。

### 顶点着色器

顶点着色器运行在每一个输入的顶点上，顶点会携带属性进入顶点着色器，例如模型的空间坐标位置、颜色、法线、纹理坐标等，输出是最终在裁剪坐标系下的位置，以及需要传递给片段着色器的属性，例如颜色和纹理坐标。这些值会在光栅化阶段被插值，以实现平滑的效果。

裁剪坐标系是一个有顶点着色器生成的四维向量，随后将四维向量全都除以最后一个向量，转为归一化的设备坐标系，这些设备归一坐标是一个将帧缓冲映射到 x:[-1,1] y:[-1,1]的坐标系，如图 

![设备归一化坐标](imgs/normalized_device_coordinates.svg)

如果你之前涉猎过计算机图形学，应该对此很熟悉。如果之前使用过 OpenGL,应该注意到这里Y轴的方向被翻转了，Z轴的坐标使用了与DirectX3D 相同的范围 [0 , 1.0]

我们的第一个三角形程序并不会应用任何的变换，只需要直接指定三个顶点作为屏幕坐标，创建出如下的图形

![三角形](imgs/triangle_coordinates.svg)

通过在顶点着色器中，设置裁剪坐标系的最后一项为1的方式，可以直接输出屏幕归一坐标系，这种方式在裁剪坐标系到屏幕归一化坐标系的转换中不会修改任何的值。

通常这些坐标数据会被存储进一个顶点缓冲区，可是在Vulkan中创建顶点缓冲区，并为其填充数据，并不容易。因此我们决定推迟这些内容的介绍，转而采用一种非正统的方式,将数据直接内置在顶点着色器中，代码如下

```glsl
#version 450

vec2 position[3] = vec2[]{
    vec2(0.0f, -0.5f),
    vec2(0.5f, 0.5f),
    vec2(-0.5f, 0.5f)
};

void main(){
    gl_Position = vec4(position[gl_VertexIndex], 0.0f, 1.0f);
}
```

主函数会被每一个顶点调用，它内建了 gl_VertexIndex 变量标识当前顶点的索引，通常会把这个顶点应用于顶点缓冲区，可是在我们的例子里，我们把这个索引值用在硬编码的一个顶点数组数据中。每一个顶点的位置都是从这个常量数组中取得的，再结合上假的z 和 w 分量，去生成出一个裁剪坐标系下的位置数据，内建的 gl_Position 是最终的输出。

### 片段着色器

三角形是由顶点着色器提供的位置，填充片段构成的屏幕上的一块区域，片段着色器会在这些片段上被调用，去给帧缓冲区提供颜色和深度。一个简单的输出红色三角形的片段着色器如下

```glsl
#version 450

layout(location = 0) out vec4 outColor;

void main(){
    outColor = vec4(1.0f , 0.0f , 0.0f, 1.0f);
}
```

像顶点着色器一样，main函数被每一个片段所调用。在片段着色器中，颜色用一个4个分量的向量来表示，分别代表R、G、B 和 Aplha 通道，取值范围是 0 ~ 1, 与顶点着色使用 gl_Position 内建变量作为输出不同，片段着色器并没有这样的内建变量作为颜色的输出。你必须为每一个帧缓冲指定自己的输出变量,这行 layout(location = 0) 就代表了帧缓冲区的索引。红色被写入到连接了第一个也是唯一一个帧缓冲区的 outColor 变量中.

### 每个顶点设置颜色

一个纯红色的三角形看起来并不有趣，下面这个更漂亮的三角形如何实现呢？

![彩色三角形](imgs/triangle_coordinates_colors.png)

我们需要对着色器做一些修改来完成这个效果。首先需要为三个顶点中的每一个都设置一个不一样的颜色，顶点着色器现在可以包含一个颜色数组，与位置数组类似。

```glsl
vec3 colors[3] = vec3[]{
    vec3(1.0f , 0.0f , 0.0f),
    vec3(0.0f , 1.0f , 0.0f),
    vec3(0.0f , 0.0f , 1.0f)
};
```

现在我们可以把每个顶点的颜色传输给片段着色器，它可以将颜色插值后输出给帧缓冲。顶点着色器中增加一个输出，main函数中写入。

```glsl
layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
```

下一步，需要在片段着色器中添加一个匹配的输入。

```glsl
layout(location = 0) in vec3 fragColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
```

输入变量没有必要与顶点着色器中的输出取一样的名字，它们是通过索引(location指定)关联在一起的，main函数已经被修改成了输出的颜色加上一个透明度的值。如上面图片所示，fragColor的值，是三个顶点自动插值完成的，这样就实现了平滑的渐变效果。

### 编译着色器

在你的工程的根目录下创建一个 shaders 目录，存储顶点着色器的代码到文件 shader.vert ,再创建一个包含片段着色器的代码文件 shader.frag , GLSL并没有一个官方的扩展名，通常用vert、frag这两个扩展名来区分它们。

shader.vert的内容

```glsl
#version 450

layout(location = 0) out vec3 fragColor;

vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);

void main() {
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    fragColor = colors[gl_VertexIndex];
}
```

shader.frag 文件内容

```GLSL
#version 450

layout(location = 0) in vec3 fragColor;

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(fragColor, 1.0);
}
```

现在可以用 glslc 将它们编译成 SPIR-V格式的字节码

#### Windows

创建一个批处理命令 compile.bat 内容如下

```bat
C:/VulkanSDK/x.x.x.x/Bin/glslc.exe shader.vert -o vert.spv
C:/VulkanSDK/x.x.x.x/Bin/glslc.exe shader.frag -o frag.spv
pause
```

用你自己的 glslc.exe 路径替换批处理命令中的，双击运行。

#### Linux

创建一个 shell文件 compile.sh，内容如下

```sh
/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.vert -o vert.spv
/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslc shader.frag -o frag.spv
```

用你自己的 glslc 路径替换命令行中的，修改compile.sh的执行权限 chmod +x compile.sh ，然后运行它。

#### 平台特定指令结束

这两行命令告诉编译器读取 GLSL 源码，使用-o 输出一个SPIR-V的二进制字节码.

如果你的着色器代码包含语法错误，编译器会告诉你哪一行报错，试着删除一个分号再运行.再试试去掉命令行的参数去运行编译器,去看看编译器支持哪些特性，也可以从SPIR-V格式输出一个人类可读的格式，以便于你去查看这个阶段，编译器做了哪些优化。

在命令行中去编译着色器的代码是最常用的一种使用方式，也是我们在此教程中会使用的，不过也支持从你的代码中直接编译着色器的代码，有关的Vulkan SDK包含在 libshaderc 中， 它是一个库，可以帮助你在程序中将GLSL代码编译成 SPIR-V 字节码。

### 载入着色器程序

现在我们已经可以生成SPIR-V格式的着色器了，是时候将它载入到我们的程序中，并在渲染管线的一些阶段使用着色器了，首先实现一个简单的载入二进制数据的辅助函数。

```C++
#include <fstream>
...

static std::vector<char> readFile(const std::string& filename) {
    std::ifstream file(filename, std::ios::ate | std::ios::binary);

    if (!file.is_open()) {
        throw std::runtime_error("failed to open file!");
    }
}
```

readFile 函数会读取指定文件的所有字节，并作为 std::vector 来返回.我们以两个标志位来打开指定文件

- ate : 从文件末尾开始读取
- binary : 将文件作为二进制读取(避免文本字符的转换)
  
在文件末尾读取，我们就可以知道文件的大小，从而分配出足够的缓存。

```C++
size_t fileSize = (size_t) file.tellg();
std::vector<char> buffer(fileSize);
```

之后我们便可以返回文件的开始处，一次读取出所有的字节

```C++
file.seekg(0);
file.read(buffer.data(), fileSize);
```

最后，关闭文件返回字节数据.

```C++
file.close();

return buffer;
```

现在，在createGraphicsPipeline中调用这个函数，去载入两个字节码。

```C++
void createGraphicsPipeline() {
    auto vertShaderCode = readFile("shaders/vert.spv");
    auto fragShaderCode = readFile("shaders/frag.spv");
}
```

确保着色器已经被正确的载入了，打印出缓冲的大小与文件实际的大小做对比，注意，这里读取的内容不需要设置结束符,因为它是二进制码，我们会显式地说明它的大小。

### 创建着色器模块

在我们把这些代码传递给管线之前，必须将它们包裹进一个 VkShaderModule 的对象中.我们创建一个辅助函数 createShaderModule 来做这些

```C++
VkShaderModule createShaderModule(std::vector<char> &code){

}
```



### 创建着色阶段

## 固定功能


## 渲染通道

## 结论
