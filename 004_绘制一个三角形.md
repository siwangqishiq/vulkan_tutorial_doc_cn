# 绘制三角形

## 安装

### 基础代码

#### 总体结构
在前一章，已经创建了基本的Vulkan工程，并用测试代码测试了它。在这一章我们将从以下的代码开始:
```
#include <vulkan/vulkan.h>

#include <iostream>
#include <stdexcept>
#include <cstdlib>

class HelloTriangleApplication{
public:
    void run(){
        initVulkan();
        mainLoop();
        cleanup();
    }

private:
    void initVulkan(){
    }

    void mainLoop(){
    }

    void cleanup(){
    }
};

int main(){
    HelloTriangleApplication app;

    try{
        app.run();
    }catch(const std::exception &e){
        std:err << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

```

首先从LunarG SDK中包含Vulkan的头文件,它提供了函数，结构体及枚举类型。```stdexcept``` 和 ```iostream``` 头文件用于报告和打印错误日志。```cstdlib```头文件提供了  ```EXIT_SUCCESS , EXIT_FAILURE ```这两个宏定义。

程序整个被包裹在一个类中，我们用这个类来保存Vulkan的对象，也会在未来添加函数用于初始化这些Vulkan对象。这些都会在```initVulkan```函数中被调用。一切都准备就绪后，我们会进入主循环开始每一帧的渲染。会在```mainloop```函数里添加一个循环，直到窗口退出才会结束此循环。会在```cleanup```中确保资源被回收。

一旦有任何致命的错误发生，都会抛出一个包含了错误描述的的```std::runtime_error``` 对象,它将会被上抛到```main```函数中，在控制台被输出。为了处理各种异常，我们捕获了最基础的```std::exception```
,很快我们就会看到一个扩展不支持的异常。

大体上，每一章都会增加一个新的函数，创建一个新的Vulkan对象，并在程序退出时将对象清理掉。


#### 资源管理

就像每一块通过malloc分配的内存都需要free掉一样，每一个我们不再需要的Vulkan对象都需要被显示的销毁掉，在C++中使用智能指针或者RAII是可能实现资源的自动管理的，但是，在这个教程中，我们会显示的分配及销毁Vulkan对象，毕竟Vulkan的优势就是显示明确地操作对象以避免错误，所以对学习Vulkan而言，显示地分配管理对象是有好处的。

在这个教程结束之后，你可以通过构造及析构函数，或者向智能指针提供自己的回收器，这视你的需求而定。RAII技术对大型的Vulkan程序是很合适的。但是对于目前的学习阶段，知道后面发生了什么，肯定更好。

Vulkan的对象要么是通过```vkCreateXXX```创建出来的，要么是通过```vkAllocateXXX```分配出来的，在确保资源已经不需要使用后，需要通过对应的```vkDestroyXXX ，vkFreeXXX ```来销毁它们。这些函数的参数有着各种各样的参数类型，但是都有一个相同的参数```pAllocator```,这是一个自定义的函数，可以让你自定义内存的分配，在教程中，我们忽略这个参数，给它传nullptr。

#### 集成GLFW库

如果你想使用离屏渲染，Vulkan在没有窗口的情况下可以工作的很好。但显示出一些东西来不是更让人兴奋吗, 我们先用以下代码替换掉原有的```#include <vulkan/vulkan.h>``` :
```
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
```

GLFW头文件会包含自己的头文件库，并自动导入Vulkan头文件。增加一个```initWindow ```函数 并在```run()```函数中去调用它,我们会使用这个函数去初始化GLFW库，并创建出一个窗口。

```
void run(){
    initWindow();
    initVulkan();
    mainLoop();
    cleanup();
}

void initWindow(){

}
```
initWindow第一句调用应该是 ```glfwInit()``` 这用于初始化GLFW库,因为GLFW库最开始是被用于创建OpenGL上下文的,我们需要告诉它在这里不需要创建OpenGL环境。使用如下代码:
```
glfwWindowHint(GLFW_CLIENT_API,GLFW_NO_API);
```
因为处理窗口大小改变事件会耗费额外的精力，我们先让窗口大小不可变
```
glfwWindowHint(GLFW_RESIZABLE,GLFW_FALSE);
```
接下来的工作就是去实际创建一个窗口了，添加一个```GLFWwindow *window;``` 将这个对象保存为一个私有的类成员对象，然后再初始化这个window。
```
windows = glfwCreateWindow( 800, 600, "Vulkan" , nullptr, nullptr);
```
前三个参数指定窗口的宽，高和标题，第四个参数指定在哪个显示器上显示窗口，最后一个参数仅对OpenGL有效，这里不管传nullptr。

使用常量代替硬编码是一个好的编程习惯，因为我们可能会在未来多次使用这些常量，在class内增加以下代码:
```
const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;
```
然后再替换之前的代码
```
windows = glfwCreateWindow( WIDTH, HEIGHT, "Vulkan" , nullptr, nullptr);
```
现在你的initWindow函数看起来应该是如下这样的;
```
void initWindow(){
    glfwInit();

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);
}
```

为了让应用程序持续运行，直到发生错误或者窗口关闭才退出，我们在mainloop函数中增加一个事件循环.
```
void mainLoop() {
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
    }
}
```
以上代码不难理解，它循环检测是否有用户关闭窗口的事件发生，这也是之后我们渲染操作需要添加的代码位置。

一旦窗口被关闭，需要清理分配的资源，结束GLFW库，在```cleanup()```中添加以下代码:
```
void cleanup(){
    glfwDestoryWindow(window);

    glfwTerminate();
}
```

当你运行此程序时，你将会看到一个标题是Vulkan的窗口显示出来，知道其被关闭掉。现在我们已经有了Vulkan程序的骨架，接下来就开始创建第一个Vulkan对象吧。

### 实例

#### 创建一个实例

初始化Vulkan库第一件要做的事就是创建一个实例 instance .实例连接了你的应用程序和Vulkan库,应用程序涉及要向驱动提供一些指定的细节。

声明一个createInstance()函数，并且在initVulkan()中调用它
```
void initVulkan(){
    createInstance();
}
```
新增一个类成员去存储这个实例
```
private:
    VkInstance instance;
```

创建一个实例，我们需要填写一个结构体,以此向应用提供一些信息，这些数据总体来说都是可选的，不过也许会给驱动层提供一些更好的优化建议（比如一些知名的游戏引擎做的特殊操作）。这个结构体被交过```VkApplicationInfo```

```
void createInstance(){
    VkApplicationInfo appInfo{};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = "Hello Triangle";
    appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.pEngineName = "No Engine";
    appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
    appInfo.apiVersion = VK_API_VERSION_1_0;
}
```
如前所述，许多的Vulkan结构体需要你指定sType类型成员。
许多Vulkan的信息事通过结构体传递的而不是函数参数,为了创建实例，需要提供一个或多个充足的结构体信息，下一个结构体就不是可选的了，它告诉驱动，我们希望使用什么样的全局扩展及验证层。全局在这里意味着整个程序都可用，而不仅限于当前实例。下一节会继续讨论。


```
VkCreateInstanceInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
createInfo.pApplicationInfo = &appInfo;
```








