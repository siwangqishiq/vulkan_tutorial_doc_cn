# 重建交换链

## 介绍

我们的应用程序现在已经成功的绘制出了三角形，可还有一些场景没有被正确处理.窗口表面会发生让交换链不再兼容的改变。比如说窗口大小的修改。我们需要重建交换链来处理这些事件。

## 交换链重建

创建一个新函数 recreateSwapChain 在里面调用 createSwapchain 以及重新创建所有依赖于交换链或窗口尺寸的对象。

```C++
void recreateSwapChain(){
    vkDeviceWaitIdle(device);

    createSwapChain();
    createImageViews();
    createFramebuffers();
}
```

首先调用 vkDeviceWaitIdle ,如前面说过的，我们并不会直接操作正在使用的资源，所以需要等待操作全部运行完毕。很明显，首先要重建交换链本身,图像视图也需要被重建因为其直接依赖于交换链提供的图像，最后帧缓冲对象也直接依赖于交换链中的图像，所以也需要被重新创建。

为了确保老的这些对象被正确清理掉，需要将 cleanup 代码中的一些操作提取出一个单独的函数, 以便于我们可以在 recreateSwapChain 中重新调用它们,我们将提出的函数命名为 cleanupSwapchain():

```C++
void cleanupSwapChain() {

}

void recreateSwapChain() {
    vkDeviceWaitIdle(device);

    cleanupSwapChain();

    createSwapChain();
    createImageViews();
    createFramebuffers();
}
```

注意我们这里并没有重建渲染通道，理论上，在应用程序的生命周期内也可能发生交换链的格式被改变的情况，例如,切换到了一台高动态显式范围的显示器上，这也许就需要应用程序去重建渲染通道，以保证适配正确的显式设备。

我们将cleanup中关联交换链的对象都提取到 cleanupSwapChain()中:

```C++
void cleanupSwapChain() {
    for (auto framebuffer : swapChainFramebuffers) {
        vkDestroyFramebuffer(device, framebuffer, nullptr);
    }

    for (auto imageView : swapChainImageViews) {
        vkDestroyImageView(device, imageView, nullptr);
    }

    vkDestroySwapchainKHR(device, swapChain, nullptr);
}

void cleanup() {
    cleanupSwapChain();

     vkDestroyPipeline(device, graphicsPipeline, nullptr);
    vkDestroyPipelineLayout(device, pipelineLayout, nullptr);

    vkDestroyRenderPass(device, renderPass, nullptr);

    for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
        vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);
        vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);
        vkDestroyFence(device, inFlightFences[i], nullptr);
    }

    vkDestroyCommandPool(device, commandPool, nullptr);

    vkDestroyDevice(device, nullptr);

    if (enableValidationLayers) {
        DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);
    }

    vkDestroySurfaceKHR(instance, surface, nullptr);
    vkDestroyInstance(instance, nullptr);

    glfwDestroyWindow(window);

    glfwTerminate();
}
```

## 交换链过时

## 处理死锁

## 显式处理尺寸改变

## 处理最小化
